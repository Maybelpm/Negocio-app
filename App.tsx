import React, { useState, useCallback, useMemo, useEffect } from 'react';
import { Product, Sale, AppView, CartItem, Location, InventoryItem } from './types';
import Sidebar from './components/Sidebar';
import Dashboard from './components/Dashboard';
import ProductsView from './components/Products';
import POSView from './components/POS';
import ReportsView from './components/Reports';
import { supabase } from './services/supabaseClient';

const App: React.FC = () => {
  const [currentView, setCurrentView] = useState<AppView>('DASHBOARD');
  const [catalog, setCatalog] = useState<Product[]>([]);
  const [locations, setLocations] = useState<Location[]>([]);
  const [inventory, setInventory] = useState<InventoryItem[]>([]);
  const [sales, setSales] = useState<Sale[]>([]);
  const [currentLocationId, setCurrentLocationId] = useState<string>('');
  const [isLoading, setIsLoading] = useState(true);

  // Fetch initial data from Supabase
  useEffect(() => {
    const fetchInitialData = async () => {
      setIsLoading(true);
      try {
        const [locationsRes, catalogRes, inventoryRes, salesRes] = await Promise.all([
          supabase.from('locations').select('*'),
          supabase.from('products').select('*'),
          supabase.from('inventory').select('*'),
          supabase.from('sales').select('*').order('date', { ascending: false })
        ]);

        if (locationsRes.data) {
          setLocations(locationsRes.data);
          if (locationsRes.data.length > 0 && !currentLocationId) {
             // Set default location only if not already set
             const storedLocation = localStorage.getItem('omnipos_current_location');
             setCurrentLocationId(storedLocation || locationsRes.data[0].id);
          }
        }
        if (catalogRes.data) setCatalog(catalogRes.data);
        if (inventoryRes.data) setInventory(inventoryRes.data);
        if (salesRes.data) setSales(salesRes.data as Sale[]); // Cast needed for jsonb type
        
      } catch (error) {
        console.error("Error fetching initial data:", error);
      } finally {
        setIsLoading(false);
      }
    };
    fetchInitialData();
  }, []);

  // Set up real-time subscriptions
  useEffect(() => {
    const channel = supabase.channel('public:db-changes')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'products' }, (payload) => {
        if (payload.eventType === 'INSERT') setCatalog(prev => [payload.new as Product, ...prev]);
        if (payload.eventType === 'UPDATE') setCatalog(prev => prev.map(p => p.id === payload.new.id ? payload.new as Product : p));
        if (payload.eventType === 'DELETE') setCatalog(prev => prev.filter(p => p.id !== (payload.old as Product).id));
      })
      .on('postgres_changes', { event: '*', schema: 'public', table: 'inventory' }, (payload) => {
        if (payload.eventType === 'INSERT') setInventory(prev => [...prev, payload.new as InventoryItem]);
        if (payload.eventType === 'UPDATE') setInventory(prev => prev.map(i => i.id === payload.new.id ? payload.new as InventoryItem : i));
        // No delete handler for inventory for now
      })
      .on('postgres_changes', { event: '*', schema: 'public', table: 'sales' }, (payload) => {
        if (payload.eventType === 'INSERT') setSales(prev => [payload.new as Sale, ...prev]);
      })
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, []);
  
  // Save current location to local storage for persistence
  useEffect(() => {
    if(currentLocationId) {
        localStorage.setItem('omnipos_current_location', currentLocationId);
    }
  }, [currentLocationId]);


  const handleSale = async (cartItems: Omit<CartItem, 'stock'>[], locationId: string) => {
    const total = cartItems.reduce((acc, item) => acc + item.price * item.quantity, 0);

    const newSale = {
      // id is generated by DB
      date: new Date().toISOString(),
      items: cartItems,
      total,
      locationId: locationId,
    };
    
    // Insert sale into DB
    const { error: saleError } = await supabase.from('sales').insert(newSale);
    if(saleError) {
        console.error("Error saving sale:", saleError);
        alert("Error al registrar la venta.");
        return;
    }

    // Update inventory for each item
    for (const item of cartItems) {
        const invItem = inventory.find(i => i.productId === item.id && i.locationId === locationId);
        if(invItem) {
            const newStock = invItem.stock - item.quantity;
            await supabase.from('inventory').update({ stock: newStock }).match({ id: invItem.id });
        }
    }
    alert("¡Venta realizada con éxito!");
  };

  const handleInventoryTransfer = async (
    productId: string,
    fromLocationId: string,
    toLocationId: string,
    quantity: number
  ) => {
    const fromItem = inventory.find(i => i.productId === productId && i.locationId === fromLocationId);
    if (!fromItem || fromItem.stock < quantity) {
        alert("Error: Stock insuficiente para realizar la transferencia.");
        return;
    }
    
    // Decrease stock from origin
    await supabase.from('inventory').update({ stock: fromItem.stock - quantity }).match({ id: fromItem.id });

    // Increase stock at destination
    const toItem = inventory.find(i => i.productId === productId && i.locationId === toLocationId);
    if (toItem) {
        await supabase.from('inventory').update({ stock: toItem.stock + quantity }).match({ id: toItem.id });
    } else {
        await supabase.from('inventory').insert({ productId, locationId: toLocationId, stock: quantity });
    }
    
    alert("Transferencia realizada con éxito.");
  };

  const productsWithStockForCurrentLocation = useMemo(() => {
    return catalog.map(product => {
      const inventoryItem = inventory.find(
        inv => inv.productId === product.id && inv.locationId === currentLocationId
      );
      return {
        ...product,
        stock: inventoryItem ? inventoryItem.stock : 0,
      };
    }).sort((a,b) => a.name.localeCompare(b.name));
  }, [catalog, inventory, currentLocationId]);

  const renderView = () => {
    if (isLoading) {
        return <div className="flex justify-center items-center h-full"><p className="text-xl">Cargando datos desde la nube...</p></div>
    }

    switch (currentView) {
      case 'DASHBOARD':
        return <Dashboard 
                  products={productsWithStockForCurrentLocation} 
                  sales={sales} 
                  locations={locations}
                  currentLocationId={currentLocationId}
                />;
      case 'POS':
        return <POSView 
                  products={productsWithStockForCurrentLocation} 
                  onSale={(cartItems) => handleSale(cartItems, currentLocationId)}
                />;
      case 'PRODUCTS':
        return <ProductsView 
                  catalog={catalog} 
                  inventory={inventory}
                  locations={locations}
                  onTransfer={handleInventoryTransfer}
                />;
      case 'REPORTS':
        return <ReportsView sales={sales} locations={locations} />;
      default:
        return <Dashboard 
                  products={productsWithStockForCurrentLocation} 
                  sales={sales} 
                  locations={locations}
                  currentLocationId={currentLocationId}
                />;
    }
  };
  
  const currentViewTitle: Record<AppView, string> = {
    DASHBOARD: 'Dashboard',
    POS: 'Punto de Venta',
    PRODUCTS: 'Productos e Inventario',
    REPORTS: 'Reportes'
  };

  return (
    <div className="flex h-screen">
      <Sidebar currentView={currentView} setView={setCurrentView} />
      <main className="flex-1 ml-64 bg-gray-900 flex flex-col">
         <header className="bg-gray-800/80 backdrop-blur-sm sticky top-0 z-20 p-4 border-b border-gray-700 flex items-center justify-between">
            <h1 className="text-xl font-bold text-white">{currentViewTitle[currentView]}</h1>
            <div className="flex items-center gap-2">
                <span className="text-sm text-gray-400">Ubicación:</span>
                 <select 
                    value={currentLocationId}
                    onChange={(e) => setCurrentLocationId(e.target.value)}
                    className="bg-gray-700 border border-gray-600 rounded-lg px-3 py-1.5 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
                    disabled={isLoading}
                >
                    {locations.map(loc => <option key={loc.id} value={loc.id}>{loc.name} ({loc.type})</option>)}
                </select>
            </div>
        </header>
        <div className="flex-1 p-4 sm:p-6 lg:p-8 overflow-y-auto">
            {renderView()}
        </div>
      </main>
    </div>
  );
};

export default App;
